<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python计算加权平均成绩和算数平均成绩的小脚本]]></title>
    <url>%2F2018%2F08%2F19%2Fpython-gpa%2F</url>
    <content type="text"><![CDATA[我校打印成绩单里面只有GPA，没有平均分让人很烦心！为了方便计算成绩，就写了个小脚本分享出来啦。123456789101112131415161718192021import win32api, win32conimport pandas as pddef get_desktop(): key = win32api.RegOpenKey(win32con.HKEY_CURRENT_USER, \ r'Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders', \ 0, win32con.KEY_READ) return win32api.RegQueryValueEx(key, 'Desktop')[0]path = get_desktop()csv_file = pd.read_csv(open(path + '\\' + "gpa.csv"))num = 0;add = 0;up = 0;down = 0for i in range(len(csv_file)): add += csv_file.at[i,"score"] num += 1 up += csv_file.at[i,"score"] * csv_file.at[i,"credit"] down += csv_file.at[i,"credit"]ans1 = add / numans2 = up / downprint("算数平均成绩为："+str(ans1))print("加权平均成绩为："+str(ans2)) 如果想要顺便计算GPA等数据，直接改循环里面就OK。使用方法：1.确认好自己装好了所需要的环境。2.将每科的成绩和学分如下图储存到csv文件。3.将csv文件放到桌面。]]></content>
      <categories>
        <category>Python小脚本</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python标准库与数据操作]]></title>
    <url>%2F2018%2F06%2F20%2Fpython-standardlibrary%2F</url>
    <content type="text"><![CDATA[Python之所以广受推崇的原因之一，就是其具有众多功能强大的库（Library）。 模块、包和库 在Python中，除了函数库，模块（Module）和包（Package）也经常被人提及，用几个简单的例子解释一下Python中模块、包和库的概念。 模块模块是一种以.py为后缀的文件，在.py文件中定义了一些常量和函数。比如：我们定义priceSequence是某一个股票交易日内开市后的日成交价格序列。priceAnalysis.py代码如下：1234567891011121314151617181920212223242526#求开盘价#股票日内交易一天内第一笔成交的成交价格定义为“开盘价”def OpenPrice(priceSequence): Open = priceSequence[0] return Open#求收盘价#股票日内交易一天内最后一笔成交的成交价格定义为“收盘价”def ClosePrice(priceSequence): Close = priceSequence[-1] return Close#求最高价#股票日内交易价格序列的最大值定义为“最高价”def HighPrice(priceSequence): High = priceSequence[0] for price in priceSequence: if price &gt; High: High = price return High#求最低价#股票日内交易价格序列的最小值定义为“最低价”def LowPrice(priceSequence): Low = priceSequence[0] for price in priceSequence: if price &lt; Low: Low = price return Low 这时候我们的就创建了一个名为priceAnalysis的模块，模块的名称就是.py脚本文件的名称。接下来我们使用import导入，就可以使用这个模块了。123456789#导入模块的语句形式import 特定模块名称import 特定模块名称 as 自定义名称#导入priceAnalysis模块import priceAnalysis as PrA#如果要导入模块内的特定函数，我们可以用from...import...语句，比如：from priceAnalysis import ClocePrice 我们把模块看作一个对象，通过“模块名称.常量名称”来获得模块内的特定变量，通过“模块名称.函数名称”来获取该模块内的特定函数。12345678910import priceAnalysis as PrAprice=[19,18,20,22,17,21]print(PrA.OpenPrice(price))#求开盘价 输出19print(PrA.ClosePrice(price))#求收盘价 输出21print(PrA.HighPrice(price))#求最高价 输出22print(PrA.LowPrice(price))#求最低价 输出17 包包体现了模块的结构化管理思想，包由模块文件构成，将众多具有相关联功能的模块文件结构化组合形成包。那么我们从编程开发的角度来看，比如两个程序员A与B将功能不同的模块文件取了相同的名字（比如为priceAnalysis），如果第三人导入了这个模块，就无法分辨出是哪个priceAnalysis模块。所以，A与B可以分别构造出一个包。将模块放到包的下面，第三人再通过“包.模块名”进行访问，那么就可以进行区分了。123456789#导入模块的语句形式import 特定模块名称import 特定模块名称 as 自定义名称#导入priceAnalysis模块import priceAnalysis as PrA#如果要导入模块内的特定函数，我们可以用from...import...语句，比如：from priceAnalysis import ClocePrice 我们把模块看作一个对象，通过“模块名称.常量名称”来获得模块内的特定变量，通过“模块名称.函数名称”来获取该模块内的特定函数。1234import stock.priceAnalysis#导入stock文件夹下面的priceAnalysis模块import future.priceAnalysis#导入future文件夹下面的priceAnalysis模块 库Python中的库是借用其他编程语言的概念，没有特别具体的定义，Python库着重强调其功能性。在Python中，具有某些功能的模块和包都可以被称作库。模块由诸多函数组成，包由诸多模块结构化构成，库中也可以包含包、模块和函数。举例来说，NumPy库是一个具有强大科学计算功能的函数库，与此同时，我们也可以把NumPy称作包，由许多丰富功能的模块构成。 Python标准库的介绍 Python标准库是Python自带的函数库，成功安装了Python就可以使用标准库。标准库中包括了内置函数（Built-in Functions）、内置常量（Built-in Constants）、内置数据类型（Built-in Types）、内置异常（Built-in Exceptions）以及众多功能函数组成的模块。这些模块中的函数用C语言编写而成。 内置函数（Built-in Functions）Python内置函数，就是Python标准库中自带的函数，Python标准库提供了一些常用功能的函数。通过代码1print(dir(__builtins__)) 即可将Python内置函数名称进行输出。 内置常量（Built-in Constants）Python内置常量是存在于Python内置命名空间中的常量，常量值不能被程序更改。在python 3.5.1版本中，布尔类型取值的True和False为内置常量；内置常量NoneType类型的None一般用于带有参数的函数的参数默认取值中，表示取值的缺失；Python的内置常量还包括NotImplemented、Ellipsis、debug、和site模块中的部分常量值等。123print(True) #输出Trueprint(False) #输出Falseprint(None) #输出None 内置数据类型（Built-in Types）数值型（Numerics）、序列（Sequences）、容器类型（Mappings）、类（Classes）、类的实例（Instances）和异常值类型（Exception）等属于Python解释器（Interpreter）中内置的数据类型（Built-in types）。 内置异常（Built-in Exceptions）内置异常是指在程序运行过程中出现的错误，包括语法错误（SyntaxError）、缩进错误（IndentationError）、系统错误（SystemError）、命名错误（NameError）等，在Python中用try…except捕捉异常，用raise抛出异常，而所有异常都从类Exception中继承。 内置模块Python标准库中的模块众多，在这里我们仅挑出几个常用的模块来阐述Python模块的使用方式和 本文部分整理转载自《量化投资：以Python为工具》蔡立耑 仅供学习研究之用，侵删。]]></content>
      <categories>
        <category>Python各种库操作</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python面向对象]]></title>
    <url>%2F2018%2F05%2F12%2Fpython-object-oriented%2F</url>
    <content type="text"><![CDATA[在编写代码时，我们通常不会毫无规划地逐条执行语句和指令，而是先有模块化（Modularization）抽象设计，希冀能使代码最大程度地重复使用，同时将设计、调试和维护等的复杂度降至最低。函数也是模块化设计的一种。而面向对象编程（Object-Oriented Programming）更是模块化设计的重要方法。 面向对象的概念 面向对象这种编程范式（Programming Paradigm）认为世界是由各式各样的对象所组成的，不同的对象之间可以相互作用和通讯。 类和对象的含义说到面向对象就不得不说类（Class），和对象的含义，比如说把一个汽车看成一个对象，那么这个小汽车对象包含的信息可能有轮胎型号、发动机型号、方向盘型号等等。这些描述对象特征的数据信息称为这个对象的属性（Attribute）；而存取属性的函数称为方法（Method），是对象与外界沟通的接口。具有相同属性与方法的对象，构成了一个类（Class）。类其实就是一种将对象抽象化而形成的概念，简单来说对象就是类的实例化（Instance）。 面向对象编程的三大特征“面向对象编程”的思想起源于20世纪60年代的Simula语言，并逐渐在各种语言上发展出三大特征：“封装”、“继承”、“多态”。 类 划重点：在Python这种动态语言中，属性与方法可以动态绑定，故同一类所产生的实例，未必具有同样的属性或方法！！！！ 一个类的不同实例123456789class Asset(object): passasset1 = Asset()asset1.id = '001'asset2 = Asset()asset2.price = 12print(asset1.id,asset2.price)## 输出001 12 看上面的例子，首先讲讲小括号里的object，小括号里面填写的是现在定义的类继承自哪一类。如果没有明显继承自哪一类，则填object，object是所有类继承的源头。然后我们来看第四行和第六行，asset1和asset2都是创建自Asset类的一个实例。而第五行和第七行则是给实例各自绑定了一个代码属性。 一个类拥有共同特征上面的例子演示了源于同一个类的不同实例，藉由动态绑定可以拥有不同的属性。这样做虽然自由，但是有悖于把类视为实例的模版惯例，也不利于软件开发与维护。如果我们希望创建同一个类的实例拥有一些共同的特征，那么我们可以定义一个特殊的方法：123456789class Asset(object): pass def __init__(self, id, price): self.id = id self.price = priceasset3 = Asset('003',100.5)print(asset3.id,asset3.price)## 输出003 100.5 首先这样写的目的在于绑定一些在创建实例时非填不可的属性。那么我们就来看看init函数的参数，首先self指的是被实例化出来的对象，一般不用传递进来，id和price则是用于给对象的属性赋值，这两个必须进行参数传递，如果在init方法中绑定的属性，在创建实例时没有传入相应的参数，那么Python就会报错。个人理解在我个人的理解init这个函数，就相当于C++的构造函数，JAVA的构造方法，作用就是定义了Python类中的变量，然后对变量进行初始化。题外话当然我们在编写Python类时，可以创建一个AssetClass.py的文件，专门存放Asset()类的定义代码。此外，创建完类的名称以后，加入一些文字说明，简要阐述类的主要内容，以方便使用者快速了解此类功能，这些文字储存成字符串形式。 封装 如果我们要打印上例中的代码id，则可以定义一个打印id的函数，我们通过调用函数，就可以将其打印出来：1234567891011def print_id(asset): print('The id of the asset is: %s' %(asset.id))class Asset(object): pass def __init__(self, id, price): self.id = id self.price = priceasset3 = Asset('003',100.5)print_id(asset3)## 输出The id of the asset is: 003 但是id属于asset3这个对象的内部属性。从软件设计的角度考虑，有些属性可能携带重要的信息或具有某些隐私性，像上例那样能够轻易地从外部函数直接访问内部属性，并不利于数据存取权限的管理。比较好的数据管理的做法是，把属性和访问属性的方法放在同一个对象中，使得信息载体和存取信息“藉由对象关联起来”。于是，我们作出了如下的修改：123456789101112class Asset(object): pass def __init__(self, id, price): self.id = id self.price = price def print_id(self): print('The id of the asset is: %s' %(self.id))asset5 = Asset('005',99.9)asset5.print_id()## 输出The id of the asset is: 005 在类中定义的方法，我们可以用“实例.方法”进行调用。这样做的另一个好处是，可以把方法的实现逻辑隐藏在类或对象的内部。但是这样仍然不能保证对象的属性被无关的函数所改变。为了限制它们不被外界访问。在Python中，属性变量前加上两个下划线表示private属性，private属性的存取只能在类的内部进行。所以我们又作出了改变：123456789101112class Asset(object): pass def __init__(self, id, price): self.__id = id self.__price = price def get_ID(self): return self.__idasset6 = Asset('006',5.21)print("The id of the asset is: %s"%(asset6.get_ID()))## 输出The id of the asset is: 006 由于private属性只能在类的内部可见，试图通过“实例.属性名称”从外部访问，那么Python就会报错。所以我们就在类的内部写了一个函数来获得id就解决了这个问题。 继承 父类（Parent Class）与子类（Child Class）继承的思想在于充分利用已有的类的功能，在已有类的基础上扩展来定义新的类。而原有的类称为父类，由父类衍生出的类称为子类。一个父类可以衍生出多个子类。子类一旦继承了父类，就拥有了父类的属性和方法，并且可以按照特殊要求对其增添与修改。这么做的好处之一就在于代码的复用性。首先我们定义一个父类：12345678910111213141516from datetime import datetimeclass Asset(object): share = 0 buyTime = datetime.strptime('1900-01-01','%Y-%m-%d') sellTime = datetime.strptime('1900-01-01', '%Y-%m-%d') def __init__(self, id, price): self.id = id self.price = price def buy(self, share, time): self.share += share self.buyTime = datetime.strptime(time,'%Y-%m-%d') def sell(self, share, time): self.share -= share self.sellTime = datetime.strptime(time, '%Y-%m-%d') OK，但是我们假设有些金融商品是不能卖空的，那么我们可以定义一个NonShortableAsset类来刻画这些不能卖空的金融商品，我们把其作为子类，直接继承父类Asset。再对Sell方法加上不能卖空的限制：123456789101112131415161718192021222324252627from datetime import datetimeclass Asset(object): share = 0 buyTime = datetime.strptime('1900-01-01','%Y-%m-%d') sellTime = datetime.strptime('1900-01-01', '%Y-%m-%d') def __init__(self, id, price): self.id = id self.price = price def buy(self, share, time): self.share += share self.buyTime = datetime.strptime(time,'%Y-%m-%d') def sell(self, share, time): self.share -= share self.sellTime = datetime.strptime(time, '%Y-%m-%d')class NonShortableAsset(Asset): def sell(self, share, time): if self.share &gt;= share: self.share -= share self.sellTime = datetime.strptime(time, '%Y-%m-%d') else: print('Not permitted!There are not enough share to sell!') print('Current share is ',self.share) return 通过继承，我们在定义子类时，不必大费周章地重复父类已经拥有的内容，只需要增加或修改想要的东西即可。当然我们也注意到当子类与父类有相同的方法时，子类的方法会覆盖（重写）父类的方法！ 本文部分整理转载自《量化投资：以Python为工具》蔡立耑 仅供学习研究之用，侵删。]]></content>
      <categories>
        <category>Python基本语法</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python函数]]></title>
    <url>%2F2018%2F05%2F04%2Fpython-function%2F</url>
    <content type="text"><![CDATA[函数，顾名思义，将一些语句集合在一起的程序结构，使得代码能够最大程度地被重复利用。通过函数我们可以很有逻辑地做模块化的思考，下面我们来介绍Python中函数的使用。 函数的定义与调用 一个例子简单明了的说明123456def func(a,b): c = a - b return ci = 100; j = 99k = func(i,j)print(k) #输出1 即100-99 = 1 首先定义了一个函数func，def定义函数的时候，只是建立了函数对象，并没有运行的动作，此时a和b被称作形式参数（简称“形参”，Formal Parameter/Parameter）。一旦调用了函数，那么在调用处会传递给函数具体的对象，比如说本例中的i，j，这些传进函数的对象被称为“实际参数”（简称“实参”，Actual Argument/Argument）。与C语言相比，Python的函数更加有弹性；从前面的例子我们可以发现，在Python中定义一个函数时，函数及其参数类型都不需要声明。就算我们传进去的实参是浮点数，Python也能正确地计算出结果。 当然前文提到的参数和返回值都不是必须的。比如，下例定义并调用了一个不需要参数的函数hello()。123def hello(): print("Hello!")hello() 如果函数需要回传一个以上对象，可以使用tuple容器实现：123456def fun(x,y): z1 = x + y z2 = x - y return z1,z2z1,z2 = fun(100,50)print(z1,z2) #输出150 50 函数的参数 1.在调用函数的时候，传入的实参一般会按照位置顺序与形参绑定。这种方式被称为传递“位置参数（Positional Argument）”。例如我们第一个例子，func（i,j）,Python就会把i的值也就是100赋值给a，j的值也就是99赋值给b。 当然，我们也可以在调用时写明实参与形参的绑定关系，这种方式被称为“关键字参数（Keyword Argument）”，如下例：123456def func(a,b): c = a - b return ci = 100; j = 99k = func(b = j,a = i) #同理 k = func(a = i,b = j)也可以print(k) #输出1 即100-99 = 1 2.如果需要同时传递位置参数和关键字参数，则位置参数的顺序应先于关键字参数，否则Python会报错。定义函数的时候，也可以为参数指定默认值。例如：123456def func(a,b = 80): c = a - b return ci = 100k = func(i)print(k) #输出20 即100-80 = 20 3.但是需要注意的是，指定参数默认值的表达式只会被执行一次。例如：123456a = 'Python'def func(words = a): print(words)func() #输出Pythona = 'JAVA'func() #默认表达式只会执行一次，所以还是输出Python 4.如果函数中传递的参数属于可变对象，那么在函数内部对此对象的修改，会在函数执行后仍然有效并影响调用者。例如：12345678def change(x,y): x[0] = 'X' y = 10words = ['x','y','z']num = 5change(words,num)print(words,num)#输出 ['X', 'y', 'z'] 5 列表words是可变对象，原来的值是[‘x’,’y’,’z’]，在传递给函数change后，其值变为[‘X’,’y’,’z’]。同时我们也注意到执行change前后，不可变对象num的值并没有发生改变。因此，如果参数的默认值是可变对象，一旦函数内部修改了该可变对象，则默认值也随之改变。例如：1234567def growing_list(x,y=[]): y.append(x) print(y)growing_list('a') #输出 ['a']growing_list('b') #输出 ['a', 'b']growing_list('c') #输出 ['a', 'b', 'c']growing_list('d') #输出 ['a', 'b', 'c', 'd'] 重点来辣可选参数——参数个数未定当函数的参数数目并不确定时，可以藉由容器类型的对象（如tuple、list、dict等）进行传递。1234567def add(addend): sum = 0 for i in addend: sum += i return sumprint(add((1,2,3))) #输出6print(add([1,2,3])) #输出6 但是这样做的不便之处在于必须先把传入的参数“打包”，如果不打包就传递，那么Python就会报错。但是如果不打包就传递参数，可在定义函数时，在不确定数目的形参前加一个“*”或者“**”。两者的差异在于一个星号的形参为空的tuple，两个星号的形参为空的dict。样例如下：1234567def add(*addend): sum = 0 for i in addend: sum += i return sumprint(add(1,2,3)) #输出6print(add(1,2,3,4,5,6)) #输出21 当然，使用不定数目的参数的另一种方式是，函数前面N个参数是固定的，之后的参数数目则不一定。例子：我们要计算某个自行定义的加权和，前面两个参数的权重分别为0.4和0.3，后面参数的权重则为0.3除以后面参数的个数。 123456789def Sum(x1,x2,*y): sum = 0 size = len(y) weight = 0.3/size for i in y: sum += weight*i sum += 0.4*x1 + 0.3*x2 return sumprint(Sum(6,7,8,9,10)) 匿名函数 函数在Python中其实也是一个对象，因此我们之前关于对象的使用方式，完全适用于函数。比如，我们可以创建一个包含函数的列表，或者把一个函数当作另一个函数的参数或者返回值来传递。这时使用匿名函数可以使代码看起来更加简洁明了。匿名函数顾名思义就是无须使用def这样的语句来定义标识符（函数名）的函数。Python使用lambda关键字来创建匿名函数。lambda语句中，冒号前面可以有任意个参数（包括无参数和可选参数），不同的参数以逗号分隔；而冒号之后是表达式，只能有一个，因此不必写return。下例演示将无参数函数greeting2改写为匿名函数greeting3的方法：123456def greeting2(): print('Hello Python!') #输出greeting2()#下面同理greeting3 = lambda : print('Hello Python!') #同样输出greeting3() 下面的例子使用匿名函数的技巧，在列表中嵌入函数的定义：123456789101112def power2(x): return x**2def power3(x): return x**3def power4(x): return x**4def power5(x): return x**5L1 = [power2,power3,power4,power5]for p in L1: print(p(3))#输出# 9# 27# 81# 243 那么我们下面使用lambda语句实现同样的功能：12345678L2 = [lambda x: x**2,lambda x: x**3,lambda x: x**4,lambda x: x**5]for p in L2: print(p(3))#输出# 9# 27# 81# 243 其实使用匿名函数之处，我们总能使用def定义的函数进行替换。从这个角度来看，匿名函数的运用更像是变成风格的选择，使用这种技巧有时可以提高代码的可读性，但也不是非用不可。 作用域 如果一个变量名在代码文件（一般指模组，Module）内部、函数外部被赋值和创建，则该变量的作用域是全局的（Global），它在该文件内部的任何地方都可见：1234x = 6def func(value): return (value + x)print(func(4)) #输出10 但是如果变量在函数内部被赋值与创建，则该变量的作用域是本地的（Local），只能在函数内部使用，在函数外部不可见（其他语言称为局部变量）：1234def fun(): y = 10print(y) # 报错，无法找到y NameError: name 'y' is not defined 如果本地变量与全局变量名称相同，那么存取到的会是本地变量。例如，之前我们已经有一个全局变量x = 6，若下面函数中再创建一个本地变量x = 60，那么本地变量会覆盖全局变量：12345x = 6def func(value): x = 60 return (x + value)print(func(10)) #输出70 运用的是本地变量 60+10 = 70 此外，虽然在函数内部可以访问全局变量，但是在函数内部却不能对其进行修改。若要在函数内部修改全局变量。可以在变量前面加上global声明语句：123456x = 6def func(): global x x = 60func()print(x) #输出60 本文部分整理转载自《量化投资：以Python为工具》蔡立耑 仅供学习研究之用，侵删。]]></content>
      <categories>
        <category>Python基本语法</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python常用语句]]></title>
    <url>%2F2018%2F05%2F03%2Fpython-statement%2F</url>
    <content type="text"><![CDATA[特别提示：本文省略或简写了一些与其他语言相同的语句及函数的使用规则，主要挑选Python特有的语句，函数语法。Python程序由模块（Module）所构成，而模块中则包含各种语句（Statement）。藉由语句的组合，指定Python执行程序的过程。Python语句可由表达式组成。表达式由运算符和操作数组成，表达式会传回一个值；而语句是一个完整的句子，其不会返回一个值。Python环境中也支持更复杂的语句，体现了不同语法与语意并对应不同的执行方式。接下来我们将一一介绍。 赋值语句 简单赋值像其他语言一样，赋值逻辑比较简单，如 a = 100，就是将等号右边的100赋值给变量a。那么我们来说说Python中的赋值过程，在Python中，我们赋给变量的是内存中对象的引用（内存中的地址），而不是对象的值。那么上代码：123456789a = [100,200,300]b = ac = [100,200,300]print(id(a)) #输出92516800print(id(b)) #输出92516800print(id(c)) #输出92397320a[1] = 500print(a[1]) #输出500print(b[1]) #输出500 由代码可见，使用赋值语句b = a，让b引用了a的列表对象，所以b和a指向的内存地址都是相同的，但是当我们拿出来一个新的列表c的时候，c引用的是新的列表对象，当我们修改了a[1]，毫不意外，b[1]也跟着一起改变。 多重赋值多重赋值就是将同一个对象的引用赋值给多个变量，即多个变量同时指向这个对象。12x = y = z = [1,2,3,4,5]print((x is y)and(x is z)and(y is z)) #输出True 多元赋值多元赋值就是将一个赋值语句实现了多个变量引用多个对象的赋值过程。12x,y,z = 100,200,300print(x,y,z) #输出100 200 300 增强赋值增强赋值的含义为对变量进行运算操作的再次赋给这个变量，如果a += 10或者a = a*10。比较常见，不多赘述。 条件语句 Python的条件语句通过判断条件的真假来确定执行哪条语句。（也就是我们常用的if语句）只是在Python中语法略有不同：1234567a = 100b = 101if a &gt; b: print('a比b的值大')else: print('b比a的值大')#本例输出 b比a的值大 如果判断条件有很多个，我们可以使用if…elif语句形式。12345678grade = 88if grade &gt;= 90: print("Excellent!")elif grade &gt;= 70 and grade &lt;90: print("good!")else: print("GG!")#本例输出 good！ 然后我们的重点来了一个比较好玩的东西，Python的条件语句可以将所有代码都放置在一个物理行中即可完成条件语句程序。上面的程序，我们可以简化成：1234a = 100b = 101print('a比b的值大') if a &gt; b else print('b比a的值大')#本例输出 b比a的值大 就像一些数学公式一样，我们将这个东西进行推广：这条语句可以用于赋值操作。即三元操作：1234a = 100b = 101a = 4**2 if a &gt; b else 4**3print(a) #输出64 即4*4*4 = 64 循环语句 Python有三种循环类型，分别为for循环、while循环和内嵌循环。与这三种循环类型相关的循环控制语句有break语句，continue语句和pass语句。那么我们下面分别来说一说： for循环for循环的作用就不再赘述，直接切入正题，for循环遍历一般需要单个语句或者一个语句块。语句块由多个语句组成。for循环语句或者语句块需要缩进，语句块内的语句和缩进格式相同。使用for循环时，要注意语句缩进的格式：12for i in [1,2,3,4,5]: print(i); #输出1 2 3 4 5 （换行输出） 1234567891011a = list();for i in 'python': a.append(i+'python') print(a)# 输出# ['ppython']# ['ppython', 'ypython']# ['ppython', 'ypython', 'tpython']# ['ppython', 'ypython', 'tpython', 'hpython']# ['ppython', 'ypython', 'tpython', 'hpython', 'opython']# ['ppython', 'ypython', 'tpython', 'hpython', 'opython', 'npython'] 但是如果print(a)没有缩进的话，则会出现不同的print的结果：123456a = list();for i in 'python': a.append(i+'python')print(a)# 输出# ['ppython', 'ypython', 'tpython', 'hpython', 'opython', 'npython'] 当然对于Python来说还有一种更简单的形式来实现上面的代码：1234a = [i + 'python' for i in 'python']print(a)# 输出# ['ppython', 'ypython', 'tpython', 'hpython', 'opython', 'npython'] while循环while循环大家用的也比较多，那么直接来看Python中具体的实现语法吧：123456789101112a = 0;while a &lt; 5: a += 1 print(a+100)print(a)#输出#101#102#103#104#105#5 嵌套循环嵌套循环指的是在一个循环语句的代码块中再嵌入一个循环：12345678x = ['a','b','c']y = [1,2]z = []for i in x: for j in y: z.append([i,j])print(z)# 输出 [['a', 1], ['a', 2], ['b', 1], ['b', 2], ['c', 1], ['c', 2]] 当然Python这么方便，当然可以用一行代码解决这个问题！12345x = ['a','b','c']y = [1,2]z = [[i,j] for i in x for j in y]print(z)# 输出 [['a', 1], ['a', 2], ['b', 1], ['b', 2], ['c', 1], ['c', 2]] break、continue和pass语句这里简单说。break表示跳出当前的整个大循环。continue表示不执行continue下面的语句，并且继续遍历剩下的循环。pass我倒是以前没见过，不过在Python中，还是很好理解的。pass语句就是用来占位的，属于空（null）操作，执行时系统没有任何反应。1234for i in range(5): if i&gt;3: pass #没有任何影响 print([i,i+1]) 本文部分整理转载自《量化投资：以Python为工具》蔡立耑 仅供学习研究之用，侵删。]]></content>
      <categories>
        <category>Python基本语法</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python运算符及使用]]></title>
    <url>%2F2018%2F05%2F02%2Fpython-operator%2F</url>
    <content type="text"><![CDATA[特别提示：本文省略或简写了一些与其他语言相同的运算符的使用规则，主要挑选Python特有的运算符语法。 常用运算符除了这里介绍的运算符外，Python还有其他运算符，但是不再一一介绍。 算数运算符Python支持的算数运算符（Arithmetic Operator）为基本的加、减、乘、除等运算，算数运算符需要有两个操作数来构成表达式。算数运算符所操作的操作数的数据类型可以为整形、浮点型、复数、布尔型等。在实数运算中，如果算数运算符中有一个操作数为浮点数，其表达式的返回值就为浮点型。当然，“+”、“*”、“%”也可以用于字符串的操作中 1.“+”：表示字符串的连接；2.“*”：表示重复输入字符串；3.“%”：表示字符串格式化。123print('Python'+'Lover') #输出 PythonLoverprint('Python'*4) #输出 PythonPythonPythonPythonprint('I love %s'%('Python')) #输出 I love Python 赋值运算符这个没什么好说的，直接上图： 比较运算符这个同样也没什么好说的，直接上图： 逻辑运算符可能图中写的有点不好理解，其实跟我们平时使用的都一样，就是换一种说法。and 就可以理解成 &amp;&amp;or 就可以理解成 ||not 就可以理解成 ！ 身份运算符身份运算符分为 is 和 is not 两种，其主要用于判断两个对象所对应的id是否相等。（P.S.这里涉及到了上一篇博文的最后一部分 可变（Mutable）与不可变（Immutable）的知识，强烈建议复习一下） 1.如果两个变量a,b指向同一个储存对象，即变量a和b的id相等，则表达式“a is b”的返回值为True，“a is not b”的返回值为False。2.如果两个变量a,b指向不同的储存对象，即变量a和b的id不相等，则表达式“a is b”的返回值为False，“a is not b”的返回值为True。3.在Python中，对象都有自己的id，身份运算符的操作对象可以是一切对象。4.大小写字母的id是不同的！布尔型的True和整数型的1的id也是不同的！5.萌新请注意，重点在这里，“is”和“==”的区别。“is”比较的是内存地址是否相等，而“==”则比较的是对象的值是否相等。“is”的判断关键取决于对象是可变的还是不可变的,而“==”只关心值是否相等。 成员运算符成员运算表示某一对象是否属于一个序列，成员运算符分为 in 和 not in 两种。 1.若a是序列b中的元素之一，则表达式“a in b”的返回值为True，表达式“a not in b”的返回值为False。2.若a不是序列b中的元素之一，则表达式“a in b”的返回值为False，表达式“a not in b”的返回值为True。12345678910a = 2b = [3,4,2]c = &#123;2,3,4&#125;d = (2,4,5)print(a in b) #输出Trueprint(a in c) #输出Trueprint(a in d) #输出Trueprint('2' in b) #输出Falseprint('2' in c) #输出Falseprint('2' in d) #输出False 注意：对于一个字符串序列来说，成员运算符的左侧的操作数必须为字符串类型，否则会报错。123a = 'abc123'b = 2print(b in a) #报错 上一句 b = 2 改为 b = '2'即可 运算符的优先级老生常谈，直接上图，优先级顺序从高到低： 具有运算功能的内置函数 特别特别好用的内置函数，Python内置函数位于Python标准库（Standard Library），Python环境自带标准库。想要查询Python的内置函数，我们可以通过Python另一个内置函数dir（）来实现1print(dir(__builtins__)) 在这里我们主要讨论的是与运算有关的内置函数。先放表，然后给大家写一下例子。12345678910111213print(sum([1.1,2.1,3.1,4.1])) #求序列元素之和，输出10.4print(pow(6,2)) #幂运算6的2次方，输出36print(divmod(6,2)) #整除（6/2）和取模（6%2），输出（3，0）print(abs(-666)) #绝对值，输出666print(all([3&gt;2,6&lt;9])) #迭代对象都为True，才输出True，输出Trueprint(all([2,3,5,6,7])) #输出Trueprint(any([2,3,5,6,7])) #迭代对象有一个为True，才输出True,输出Trueprint(any([])) #迭代对象为空，输出Falseprint(max(6,9)) #输出最大值，输出9print(max([2,3,5,6,7])) #输出7print(min(6,9)) #输出最小值，输出6print(min([2,3,5,6,7])) #输出2print(round(3.748,2)) #求与3.748相近的数，返回小数点2位，输出3.75 本文部分整理转载自《量化投资：以Python为工具》蔡立耑 仅供学习研究之用，侵删。]]></content>
      <categories>
        <category>Python基本语法</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python对象类型]]></title>
    <url>%2F2018%2F05%2F01%2Fpython-object%2F</url>
    <content type="text"><![CDATA[数值类型 Python的数值类型分为：int、long、float、bool、complex（复数）其中要特别注意的是：1.float类型是近似值，并不是精确值，浮点数可由计算机硬件的浮点运算单元直接运算，在运算性能上有优势。2.复数是把一个数字分为实部和虚部两个部分，用数学式表示成a+bi的形式，其中，a和b是实数，分别称为复数的实部和虚部，i是虚数单位，且满足i^2=-1。 complex(3,6) #表示 3+6j当然我们也可以直接用3+6j #代码同样正确 字符串类型 字符串一旦创建，元素不可改变。Python没有字符这种类型，字符在Python中相当于“仅有一个字符的字符串”。 容器类型 Python的容器类型分为：list（列表）、set（集合）、dict（字典）、tuple（元组） list（列表）list（列表）可以放入任何类型的对象，因此可以视为Python语言最通用的序列。创建列表的语法是使用方括号[]包住内含的对象1234L0 = [1,2,3]L1 = ['stock A','stock B','stock C']print(L0[2]) #结果输出 3print(L1[0]) #结果输出 stock A 当然列表可以放入任何类型的对象，包括列表本身：1234L2 = [10, 'Price', ['Industry 1','Industry 2']]print(L2) #结果输出 [10, 'Price', ['Industry 1','Industry 2']]print(L2[2]) #结果输出 ['Industry 1', 'Industry 2']print(L2[2][1]) #结果输出 Industry 2 tuple（元组）tuple(元组)也是一种序列类型的数据，元组和列表都能储存任何类型的数据，但是列表中的数据是可变的（增删改），而元组一旦创建，就无法改变。元组的创建通过圆括号()来实现12M = ('Market', 3.0, [10,20,30])print(M) #输出('Market', 3.0, [10,20,30]) 需要注意的是：在进行数据运算时，圆括号常常被用来改变运算顺序。因此，在创建只包含一个对象的元组时，为了避免歧义，Python规定在这个唯一的对象后面加一个逗号。1234t1 = ('Single')print(type(t1)) #输出&lt;class 'str'&gt; 表示字符串类型t2 = ('Single',)print(type(t2)) #输出&lt;class 'tuple'&gt; 表示元组类型 相比较于列表的内容能随意改变，元组不可变的特性，在开发大型软件时有便利之处，将不需要修改的数据改成元组，可以防止误写而使代码更安全。 dict（字典）dict（字典）是一种“映射（Mapping）”的数据结构，与序列是截然不同的概念。列表、元组都是序列类型的数据结构，所谓序列指的是其中的对象从0开始依序编号，故有前后顺序的关系。字典储存是“键：值”配对这样的映射关系，透过键便可以查找相对应的值。创建字典使用大括号{}12d1 = &#123;'Stock A':30, 'Stock B':40&#125;print(d1['Stock A']) #输出 30 set（集合）之前提到的序列（例如列表和元组）与映射（如字典）是Python中用法迥异的两种容器类型。现在要介绍的集合（set）也是一种容器类型，但其既不是序列也不是映射，集合用来记录某些无顺序关系的不可变对象是否存在于其中。需要注意的是：集合没有重复的元素。创建集合的语法是以大括号包住集合元素，或将集合元素以列表的形式传入内置函数set()。1234Winnners = &#123;'Company A','Company B'&#125;print(type(Winnners)) #输出&lt;class 'set'&gt; 表示集合类型Losers = set(['Company A','Company B'])print(type(Losers)) #输出&lt;class 'set'&gt; 表示集合类型 需要注意的几点如下：1.集合中的元素没有顺序关系，所以索引存取会报错。2.空集合只能使用set（）函数创建，不能用大括号，因为没包含任何元素的大括号｛｝表示的是一个空字典。3.如果要利用字符串中的个别字符或列表中的元素来创建集合，同样必须使用set（）函数而不能用大括号。4.若以大括号包住字符串，Python仍会创建一个集合，只不过整个字符串会被当成一个单独的元素。5.利用集合没有顺序关系与不能重复的特性，我们可以检查两个列表是否包含相同的元素。12345L1 = [1,2,3]L2 = [1,2,3]a = set(L1)b = set(L2)print(a == b) #输出为True 表示两个集合相等 可变（Mutable）与不可变（Immutable） 最后写一点Python原理机制的东西。在讨论可变与不可变之前，我们先来复习一下Python解释器对以下表达式的处理过程 x = 7Python解释器先判断等号右面的7在内存中是否存在；如果不存在，Python会根据7的类型（整数）分配内存，并在此内存中创建数字7。然后再看看变量x是否存在，若不存在，创建x，最后再将7赋值给x。谨记上述过程后，我们再来看一个例子y = 7 1234x = 7y = 7print(id(x)) #输出1698027408print(id(y)) #输出1698027408 从上例看出，x与y同时指向了同一个内存地址1698027408（创建的时候内存随机），即存放整数7的地方。其实对于Python来说，整数是不可变的对象，一旦在内存建立不可变对象后，其值就无法更动。变量的名称可以指向别的对象，但无法修改已创建的不可变对象的内容。这样做的优点是，Python可以为不可变的对象分配固定内存，重用它，以减少重复的值对内存空间的占用。可变类型： 列表，字典不可变类型： 整数，浮点数，字符串，元组 本文部分整理转载自《量化投资：以Python为工具》蔡立耑 仅供学习研究之用，侵删。]]></content>
      <categories>
        <category>Python基本语法</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github+hexo+next博客搭建与优化主题资料整合]]></title>
    <url>%2F2018%2F04%2F17%2FGithub-hexo-next%2F</url>
    <content type="text"><![CDATA[哇哦，经过两个下午的愉悦努力，终于把博客做好了！在此博客的搭建过程中看了很多前辈写的教程，为了方便后来人，在此将资源进行整合。希望对你们有帮助！ hexo本地项目及与GitHub仓库的关联这部分按照步骤来就可以了，最后遇到了一点小问题，总之先放主要的链接：使用GitHub和hexo搭建博客过程 最后我的博客css没有加载进来，传上来的只有各种文字。 这时候要在项目根目录下的_config.yml文件中寻找url，将url后面加上你博客的地址就可以了比如我的: 1【url: https://jinkelababy.github.io/】 next主题的优化32种个性化教程（包括大多数你需要的东西）next主题的优化也算是找了很久，最后发现了一个小哥哥写的简单易懂，而且功能齐全，把链接贴出来给大家分享：hexo的next主题个性化教程:打造炫酷网站 如果这些还不能满足你，有一个小姐姐写的更加齐全，但是个人感觉没有上面的小哥哥的简单易懂：打造个性超赞博客Hexo+NexT+GithubPages的超深度优化 gitalk评论系统大概功能做好以后，一直觉得没有评论系统，不能和在座优秀的人才交流，很可惜。那么完美星人的我又开始到处折腾，于是找到了干货：Hexo NexT主题中集成gitalk评论系统 结束语这就是我两个下午的成果了，希望这些能对大家有所帮助，如果有帮助希望你们能到处分享一下~欢迎评论，欢迎分享！本博客会更新一些诸如算法题，项目源码的文章，如果感兴趣可以关注一下~（鞠躬）。]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
</search>
