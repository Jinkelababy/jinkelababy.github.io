<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python常用语句]]></title>
    <url>%2F2018%2F05%2F03%2Fpython-statement%2F</url>
    <content type="text"><![CDATA[特别提示：本文省略或简写了一些与其他语言相同的语句及函数的使用规则，主要挑选Python特有的语句，函数语法。Python程序由模块（Module）所构成，而模块中则包含各种语句（Statement）。藉由语句的组合，指定Python执行程序的过程。Python语句可由表达式组成。表达式由运算符和操作数组成，表达式会传回一个值；而语句是一个完整的句子，其不会返回一个值。Python环境中也支持更复杂的语句，体现了不同语法与语意并对应不同的执行方式。接下来我们将一一介绍。 赋值语句 简单赋值像其他语言一样，赋值逻辑比较简单，如 a = 100，就是将等号右边的100赋值给变量a。那么我们来说说Python中的赋值过程，在Python中，我们赋给变量的是内存中对象的引用（内存中的地址），而不是对象的值。那么上代码：123456789a = [100,200,300]b = ac = [100,200,300]print(id(a)) #输出92516800print(id(b)) #输出92516800print(id(c)) #输出92397320a[1] = 500print(a[1]) #输出500print(b[1]) #输出500 由代码可见，使用赋值语句b = a，让b引用了a的列表对象，所以b和a指向的内存地址都是相同的，但是当我们拿出来一个新的列表c的时候，c引用的是新的列表对象，当我们修改了a[1]，毫不意外，b[1]也跟着一起改变。 多重赋值多重赋值就是将同一个对象的引用赋值给多个变量，即多个变量同时指向这个对象。12x = y = z = [1,2,3,4,5]print((x is y)and(x is z)and(y is z)) #输出True 多元赋值多元赋值就是将一个赋值语句实现了多个变量引用多个对象的赋值过程。12x,y,z = 100,200,300print(x,y,z) #输出100 200 300 增强赋值增强赋值的含义为对变量进行运算操作的再次赋给这个变量，如果a += 10或者a = a*10。比较常见，不多赘述。 条件语句 Python的条件语句通过判断条件的真假来确定执行哪条语句。（也就是我们常用的if语句）只是在Python中语法略有不同：1234567a = 100b = 101if a &gt; b: print('a比b的值大')else: print('b比a的值大')#本例输出 b比a的值大 如果判断条件有很多个，我们可以使用if…elif语句形式。12345678grade = 88if grade &gt;= 90: print("Excellent!")elif grade &gt;= 70 and grade &lt;90: print("good!")else: print("GG!")#本例输出 good！ 然后我们的重点来了一个比较好玩的东西，Python的条件语句可以将所有代码都放置在一个物理行中即可完成条件语句程序。上面的程序，我们可以简化成：1234a = 100b = 101print('a比b的值大') if a &gt; b else print('b比a的值大')#本例输出 b比a的值大 就像一些数学公式一样，我们将这个东西进行推广：这条语句可以用于赋值操作。即三元操作：1234a = 100b = 101a = 4**2 if a &gt; b else 4**3print(a) #输出64 即4*4*4 = 64 循环语句 Python有三种循环类型，分别为for循环、while循环和内嵌循环。与这三种循环类型相关的循环控制语句有break语句，continue语句和pass语句。那么我们下面分别来说一说： for循环for循环的作用就不再赘述，直接切入正题，for循环遍历一般需要单个语句或者一个语句块。语句块由多个语句组成。for循环语句或者语句块需要缩进，语句块内的语句和缩进格式相同。使用for循环时，要注意语句缩进的格式：12for i in [1,2,3,4,5]: print(i); #输出1 2 3 4 5 （换行输出） 1234567891011a = list();for i in 'python': a.append(i+'python') print(a)# 输出# ['ppython']# ['ppython', 'ypython']# ['ppython', 'ypython', 'tpython']# ['ppython', 'ypython', 'tpython', 'hpython']# ['ppython', 'ypython', 'tpython', 'hpython', 'opython']# ['ppython', 'ypython', 'tpython', 'hpython', 'opython', 'npython'] 但是如果print(a)没有缩进的话，则会出现不同的print的结果：123456a = list();for i in 'python': a.append(i+'python')print(a)# 输出# ['ppython', 'ypython', 'tpython', 'hpython', 'opython', 'npython'] 当然对于Python来说还有一种更简单的形式来实现上面的代码：1234a = [i + 'python' for i in 'python']print(a)# 输出# ['ppython', 'ypython', 'tpython', 'hpython', 'opython', 'npython'] while循环while循环大家用的也比较多，那么直接来看Python中具体的实现语法吧：123456789101112a = 0;while a &lt; 5: a += 1 print(a+100)print(a)#输出#101#102#103#104#105#5 嵌套循环嵌套循环指的是在一个循环语句的代码块中再嵌入一个循环：12345678x = ['a','b','c']y = [1,2]z = []for i in x: for j in y: z.append([i,j])print(z)# 输出 [['a', 1], ['a', 2], ['b', 1], ['b', 2], ['c', 1], ['c', 2]] 当然Python这么方便，当然可以用一行代码解决这个问题！12345x = ['a','b','c']y = [1,2]z = [[i,j] for i in x for j in y]print(z)# 输出 [['a', 1], ['a', 2], ['b', 1], ['b', 2], ['c', 1], ['c', 2]] break、continue和pass语句这里简单说。break表示跳出当前的整个大循环。continue表示不执行continue下面的语句，并且继续遍历剩下的循环。pass我倒是以前没见过，不过在Python中，还是很好理解的。pass语句就是用来占位的，属于空（null）操作，执行时系统没有任何反应。1234for i in range(5): if i&gt;3: pass #没有任何影响 print([i,i+1]) 本文部分整理转载自《量化投资：以Python为工具》蔡立耑 仅供学习研究之用，侵删。]]></content>
      <categories>
        <category>Python基本语法</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python运算符及使用]]></title>
    <url>%2F2018%2F05%2F02%2Fpython-operator%2F</url>
    <content type="text"><![CDATA[特别提示：本文省略或简写了一些与其他语言相同的运算符的使用规则，主要挑选Python特有的运算符语法。 常用运算符除了这里介绍的运算符外，Python还有其他运算符，但是不再一一介绍。 算数运算符Python支持的算数运算符（Arithmetic Operator）为基本的加、减、乘、除等运算，算数运算符需要有两个操作数来构成表达式。算数运算符所操作的操作数的数据类型可以为整形、浮点型、复数、布尔型等。在实数运算中，如果算数运算符中有一个操作数为浮点数，其表达式的返回值就为浮点型。当然，“+”、“*”、“%”也可以用于字符串的操作中 1.“+”：表示字符串的连接；2.“*”：表示重复输入字符串；3.“%”：表示字符串格式化。123print('Python'+'Lover') #输出 PythonLoverprint('Python'*4) #输出 PythonPythonPythonPythonprint('I love %s'%('Python')) #输出 I love Python 赋值运算符这个没什么好说的，直接上图： 比较运算符这个同样也没什么好说的，直接上图： 逻辑运算符可能图中写的有点不好理解，其实跟我们平时使用的都一样，就是换一种说法。and 就可以理解成 &amp;&amp;or 就可以理解成 ||not 就可以理解成 ！ 身份运算符身份运算符分为 is 和 is not 两种，其主要用于判断两个对象所对应的id是否相等。（P.S.这里涉及到了上一篇博文的最后一部分 可变（Mutable）与不可变（Immutable）的知识，强烈建议复习一下） 1.如果两个变量a,b指向同一个储存对象，即变量a和b的id相等，则表达式“a is b”的返回值为True，“a is not b”的返回值为False。2.如果两个变量a,b指向不同的储存对象，即变量a和b的id不相等，则表达式“a is b”的返回值为False，“a is not b”的返回值为True。3.在Python中，对象都有自己的id，身份运算符的操作对象可以是一切对象。4.大小写字母的id是不同的！布尔型的True和整数型的1的id也是不同的！5.萌新请注意，重点在这里，“is”和“==”的区别。“is”比较的是内存地址是否相等，而“==”则比较的是对象的值是否相等。“is”的判断关键取决于对象是可变的还是不可变的,而“==”只关心值是否相等。 成员运算符成员运算表示某一对象是否属于一个序列，成员运算符分为 in 和 not in 两种。 1.若a是序列b中的元素之一，则表达式“a in b”的返回值为True，表达式“a not in b”的返回值为False。2.若a不是序列b中的元素之一，则表达式“a in b”的返回值为False，表达式“a not in b”的返回值为True。12345678910a = 2b = [3,4,2]c = &#123;2,3,4&#125;d = (2,4,5)print(a in b) #输出Trueprint(a in c) #输出Trueprint(a in d) #输出Trueprint('2' in b) #输出Falseprint('2' in c) #输出Falseprint('2' in d) #输出False 注意：对于一个字符串序列来说，成员运算符的左侧的操作数必须为字符串类型，否则会报错。123a = 'abc123'b = 2print(b in a) #报错 上一句 b = 2 改为 b = '2'即可 运算符的优先级老生常谈，直接上图，优先级顺序从高到低： 具有运算功能的内置函数 特别特别好用的内置函数，Python内置函数位于Python标准库（Standard Library），Python环境自带标准库。想要查询Python的内置函数，我们可以通过Python另一个内置函数dir（）来实现1print(dir(__builtins__)) 在这里我们主要讨论的是与运算有关的内置函数。先放表，然后给大家写一下例子。12345678910111213print(sum([1.1,2.1,3.1,4.1])) #求序列元素之和，输出10.4print(pow(6,2)) #幂运算6的2次方，输出36print(divmod(6,2)) #整除（6/2）和取模（6%2），输出（3，0）print(abs(-666)) #绝对值，输出666print(all([3&gt;2,6&lt;9])) #迭代对象都为True，才输出True，输出Trueprint(all([2,3,5,6,7])) #输出Trueprint(any([2,3,5,6,7])) #迭代对象有一个为True，才输出True,输出Trueprint(any([])) #迭代对象为空，输出Falseprint(max(6,9)) #输出最大值，输出9print(max([2,3,5,6,7])) #输出7print(min(6,9)) #输出最小值，输出6print(min([2,3,5,6,7])) #输出2print(round(3.748,2)) #求与3.748相近的数，返回小数点2位，输出3.75 本文部分整理转载自《量化投资：以Python为工具》蔡立耑 仅供学习研究之用，侵删。]]></content>
      <categories>
        <category>Python基本语法</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python对象类型]]></title>
    <url>%2F2018%2F05%2F01%2Fpython-object%2F</url>
    <content type="text"><![CDATA[数值类型 Python的数值类型分为：int、long、float、bool、complex（复数）其中要特别注意的是：1.float类型是近似值，并不是精确值，浮点数可由计算机硬件的浮点运算单元直接运算，在运算性能上有优势。2.复数是把一个数字分为实部和虚部两个部分，用数学式表示成a+bi的形式，其中，a和b是实数，分别称为复数的实部和虚部，i是虚数单位，且满足i^2=-1。 complex(3,6) #表示 3+6j当然我们也可以直接用3+6j #代码同样正确 字符串类型 字符串一旦创建，元素不可改变。Python没有字符这种类型，字符在Python中相当于“仅有一个字符的字符串”。 容器类型 Python的容器类型分为：list（列表）、set（集合）、dict（字典）、tuple（元组） list（列表）list（列表）可以放入任何类型的对象，因此可以视为Python语言最通用的序列。创建列表的语法是使用方括号[]包住内含的对象1234L0 = [1,2,3]L1 = ['stock A','stock B','stock C']print(L0[2]) #结果输出 3print(L1[0]) #结果输出 stock A 当然列表可以放入任何类型的对象，包括列表本身：1234L2 = [10, 'Price', ['Industry 1','Industry 2']]print(L2) #结果输出 [10, 'Price', ['Industry 1','Industry 2']]print(L2[2]) #结果输出 ['Industry 1', 'Industry 2']print(L2[2][1]) #结果输出 Industry 2 tuple（元组）tuple(元组)也是一种序列类型的数据，元组和列表都能储存任何类型的数据，但是列表中的数据是可变的（增删改），而元组一旦创建，就无法改变。元组的创建通过圆括号()来实现12M = ('Market', 3.0, [10,20,30])print(M) #输出('Market', 3.0, [10,20,30]) 需要注意的是：在进行数据运算时，圆括号常常被用来改变运算顺序。因此，在创建只包含一个对象的元组时，为了避免歧义，Python规定在这个唯一的对象后面加一个逗号。1234t1 = ('Single')print(type(t1)) #输出&lt;class 'str'&gt; 表示字符串类型t2 = ('Single',)print(type(t2)) #输出&lt;class 'tuple'&gt; 表示元组类型 相比较于列表的内容能随意改变，元组不可变的特性，在开发大型软件时有便利之处，将不需要修改的数据改成元组，可以防止误写而使代码更安全。 dict（字典）dict（字典）是一种“映射（Mapping）”的数据结构，与序列是截然不同的概念。列表、元组都是序列类型的数据结构，所谓序列指的是其中的对象从0开始依序编号，故有前后顺序的关系。字典储存是“键：值”配对这样的映射关系，透过键便可以查找相对应的值。创建字典使用大括号{}12d1 = &#123;'Stock A':30, 'Stock B':40&#125;print(d1['Stock A']) #输出 30 set（集合）之前提到的序列（例如列表和元组）与映射（如字典）是Python中用法迥异的两种容器类型。现在要介绍的集合（set）也是一种容器类型，但其既不是序列也不是映射，集合用来记录某些无顺序关系的不可变对象是否存在于其中。需要注意的是：集合没有重复的元素。创建集合的语法是以大括号包住集合元素，或将集合元素以列表的形式传入内置函数set()。1234Winnners = &#123;'Company A','Company B'&#125;print(type(Winnners)) #输出&lt;class 'set'&gt; 表示集合类型Losers = set(['Company A','Company B'])print(type(Losers)) #输出&lt;class 'set'&gt; 表示集合类型 需要注意的几点如下：1.集合中的元素没有顺序关系，所以索引存取会报错。2.空集合只能使用set（）函数创建，不能用大括号，因为没包含任何元素的大括号｛｝表示的是一个空字典。3.如果要利用字符串中的个别字符或列表中的元素来创建集合，同样必须使用set（）函数而不能用大括号。4.若以大括号包住字符串，Python仍会创建一个集合，只不过整个字符串会被当成一个单独的元素。5.利用集合没有顺序关系与不能重复的特性，我们可以检查两个列表是否包含相同的元素。12345L1 = [1,2,3]L2 = [1,2,3]a = set(L1)b = set(L2)print(a == b) #输出为True 表示两个集合相等 可变（Mutable）与不可变（Immutable） 最后写一点Python原理机制的东西。在讨论可变与不可变之前，我们先来复习一下Python解释器对以下表达式的处理过程 x = 7Python解释器先判断等号右面的7在内存中是否存在；如果不存在，Python会根据7的类型（整数）分配内存，并在此内存中创建数字7。然后再看看变量x是否存在，若不存在，创建x，最后再将7赋值给x。谨记上述过程后，我们再来看一个例子y = 7 1234x = 7y = 7print(id(x)) #输出1698027408print(id(y)) #输出1698027408 从上例看出，x与y同时指向了同一个内存地址1698027408（创建的时候内存随机），即存放整数7的地方。其实对于Python来说，整数是不可变的对象，一旦在内存建立不可变对象后，其值就无法更动。变量的名称可以指向别的对象，但无法修改已创建的不可变对象的内容。这样做的优点是，Python可以为不可变的对象分配固定内存，重用它，以减少重复的值对内存空间的占用。可变类型： 列表，字典不可变类型： 整数，浮点数，字符串，元组 本文部分整理转载自《量化投资：以Python为工具》蔡立耑 仅供学习研究之用，侵删。]]></content>
      <categories>
        <category>Python基本语法</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github+hexo+next博客搭建与优化主题资料整合]]></title>
    <url>%2F2018%2F04%2F17%2FGithub-hexo-next%2F</url>
    <content type="text"><![CDATA[哇哦，经过两个下午的愉悦努力，终于把博客做好了！在此博客的搭建过程中看了很多前辈写的教程，为了方便后来人，在此将资源进行整合。希望对你们有帮助！ hexo本地项目及与GitHub仓库的关联这部分按照步骤来就可以了，最后遇到了一点小问题，总之先放主要的链接：使用GitHub和hexo搭建博客过程 最后我的博客css没有加载进来，传上来的只有各种文字。 这时候要在项目根目录下的_config.yml文件中寻找url，将url后面加上你博客的地址就可以了比如我的: 1【url: https://jinkelababy.github.io/】 next主题的优化32种个性化教程（包括大多数你需要的东西）next主题的优化也算是找了很久，最后发现了一个小哥哥写的简单易懂，而且功能齐全，把链接贴出来给大家分享：hexo的next主题个性化教程:打造炫酷网站 如果这些还不能满足你，有一个小姐姐写的更加齐全，但是个人感觉没有上面的小哥哥的简单易懂：打造个性超赞博客Hexo+NexT+GithubPages的超深度优化 gitalk评论系统大概功能做好以后，一直觉得没有评论系统，不能和在座优秀的人才交流，很可惜。那么完美星人的我又开始到处折腾，于是找到了干货：Hexo NexT主题中集成gitalk评论系统 结束语这就是我两个下午的成果了，希望这些能对大家有所帮助，如果有帮助希望你们能到处分享一下~欢迎评论，欢迎分享！本博客会更新一些诸如算法题，项目源码的文章，如果感兴趣可以关注一下~（鞠躬）。]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F04%2F15%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
</search>
